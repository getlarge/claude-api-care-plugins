#!/usr/bin/env node
// @ts-check
/**
 * AIP OpenAPI Discovery CLI
 *
 * Find and analyze OpenAPI specifications in a codebase.
 *
 * @example
 * # Discover specs in current directory
 * node discover.js
 *
 * # Discover specs in specific directory
 * node discover.js ./api
 *
 * # JSON output
 * node discover.js --format json
 *
 * @module discover
 */

import { glob, readFile } from 'node:fs/promises';
import { resolve, relative, basename } from 'node:path';
import { parseArgs } from 'node:util';
import OASNormalize from 'oas-normalize';
import Oas from 'oas';

/**
 * @typedef {Object} SpecInfo
 * @property {string} path - Relative path to spec file
 * @property {string} absolutePath - Absolute path to spec file
 * @property {string} filename - Just the filename
 * @property {'openapi-3.x' | 'openapi-3.1' | 'swagger-2.x' | 'unknown'} type
 * @property {string} version - OpenAPI/Swagger version string
 * @property {string} title - API title
 * @property {string} apiVersion - API version from info.version
 * @property {string} [description] - API description
 * @property {number} pathCount - Number of paths
 * @property {number} operationCount - Number of operations
 * @property {string[]} [servers] - Server URLs
 * @property {string[]} [tags] - API tags
 * @property {boolean} isGenerated - Whether spec appears auto-generated
 * @property {string} [generatorComment] - Generator comment if found
 * @property {Error} [error] - Parse error if failed
 */

/**
 * @typedef {Object} DiscoveryResult
 * @property {string} searchPath - Directory searched
 * @property {string} discoveredAt - ISO timestamp
 * @property {SpecInfo[]} specs - Found specifications
 * @property {Object} summary
 * @property {number} summary.total
 * @property {number} summary.openapi3
 * @property {number} summary.swagger2
 * @property {number} summary.parseErrors
 */

/** @type {import('node:util').ParseArgsConfig} */
const argsConfig = {
  options: {
    help: { type: 'boolean', short: 'h', default: false },
    format: { type: 'string', short: 'f', default: 'markdown' },
    ignore: { type: 'string', short: 'i', multiple: true, default: [] },
  },
  allowPositionals: true,
  strict: false,
};

/**
 * Default glob patterns to ignore
 */
const DEFAULT_IGNORES = [
  '**/node_modules/**',
  '**/.git/**',
  '**/dist/**',
  '**/build/**',
  '**/coverage/**',
  '**/.next/**',
  '**/.nuxt/**',
];

/**
 * Glob patterns to find OpenAPI specs
 */
const GLOB_PATTERNS = [
  '**/openapi.{yaml,yml,json}',
  '**/swagger.{yaml,yml,json}',
  '**/api.{yaml,yml,json}',
  '**/*openapi*.{yaml,yml,json}',
  '**/*swagger*.{yaml,yml,json}',
];

/**
 * Find spec files using native glob
 * @param {string} dir - Directory to search
 * @param {string[]} [ignores] - Glob patterns to ignore (defaults to DEFAULT_IGNORES)
 * @returns {Promise<string[]>}
 */
async function findSpecFiles(dir, ignores = DEFAULT_IGNORES) {
  /** @type {Set<string>} */
  const results = new Set();

  const matches = glob(GLOB_PATTERNS, { cwd: dir, exclude: ignores });

  for await (const match of matches) {
    results.add(resolve(dir, match));
  }

  return [...results];
}

/**
 * Check if content looks like OpenAPI/Swagger
 * @param {string} content
 * @returns {boolean}
 */
function looksLikeSpec(content) {
  return (
    content.includes('openapi:') ||
    content.includes('"openapi":') ||
    content.includes('swagger:') ||
    content.includes('"swagger":')
  );
}

/**
 * Detect if spec was auto-generated
 * @param {string} content
 * @returns {{isGenerated: boolean, comment?: string}}
 */
function detectGenerated(content) {
  const patterns = [
    /# Generated by/i,
    /<!-- Generated by/i,
    /"x-generator":/i,
    /x-generator:/i,
    /Generated with/i,
    /Auto-generated/i,
    /DO NOT EDIT/i,
  ];

  for (const pattern of patterns) {
    const match = content.match(pattern);
    if (match) {
      // Try to extract the full comment line
      const lines = content.split('\n');
      const line = lines.find((l) => pattern.test(l));
      return { isGenerated: true, comment: line?.trim() };
    }
  }

  return { isGenerated: false };
}

/**
 * Parse and analyze a single spec file
 * @param {string} filePath
 * @param {string} basePath
 * @returns {Promise<SpecInfo>}
 */
async function analyzeSpec(filePath, basePath) {
  const relativePath = relative(basePath, filePath);
  const content = await readFile(filePath, 'utf-8');

  /** @type {SpecInfo} */
  const info = {
    path: relativePath,
    absolutePath: filePath,
    filename: basename(filePath),
    type: 'unknown',
    version: '',
    title: '',
    apiVersion: '',
    pathCount: 0,
    operationCount: 0,
    isGenerated: false,
  };

  // Check if it looks like a spec
  if (!looksLikeSpec(content)) {
    info.error = new Error(
      'File does not appear to be an OpenAPI/Swagger specification'
    );
    return info;
  }

  // Detect generated
  const generated = detectGenerated(content);
  info.isGenerated = generated.isGenerated;
  if (generated.comment) {
    info.generatorComment = generated.comment;
  }

  // Parse with oas-normalize, then use Oas for rich metadata
  try {
    const normalizer = new OASNormalize(filePath, { enablePaths: true });
    // Validate first to catch errors, then bundle to get the parsed spec
    await normalizer.validate();
    const api = await normalizer.bundle();

    // @ts-ignore - api shape varies
    if (api.openapi) {
      // @ts-ignore
      info.version = api.openapi;
      // @ts-ignore
      info.type = api.openapi.startsWith('3.1') ? 'openapi-3.1' : 'openapi-3.x';
      // @ts-ignore
    } else if (api.swagger) {
      // @ts-ignore
      info.version = api.swagger;
      info.type = 'swagger-2.x';
    }

    // Use Oas class for richer metadata extraction
    // @ts-ignore
    const oas = new Oas(api);

    info.title = oas.getDefinition().info?.title || 'Untitled';
    info.apiVersion = oas.getDefinition().info?.version || '';
    info.description = oas.getDefinition().info?.description;

    // Get paths and operations using Oas API
    const paths = oas.getPaths();
    info.pathCount = Object.keys(oas.getDefinition().paths || {}).length;
    info.operationCount = Object.values(paths).flat().length;

    // Get tags for additional context
    const tags = oas.getTags();
    if (tags.length > 0) {
      info.tags = tags;
    }

    // Get servers
    const definition = oas.getDefinition();
    // @ts-ignore
    if (definition.servers && definition.servers.length > 0) {
      // @ts-ignore
      info.servers = definition.servers.map((s) => s.url);
    }
  } catch (err) {
    info.error = err instanceof Error ? err : new Error(String(err));
  }

  return info;
}

/**
 * Format output as Markdown
 * @param {DiscoveryResult} result
 * @returns {string}
 */
function formatMarkdown(result) {
  const lines = [
    '---',
    `date: ${result.discoveredAt}`,
    'discovered_by: aip-discover',
    'status: complete',
    '---',
    '',
    '# API Discovery Report',
    '',
    `**Date:** ${result.discoveredAt}`,
    `**Search Path:** \`${result.searchPath}\``,
    '',
    '## Summary',
    '',
    '| Type | Count |',
    '| ---- | ----- |',
    `| OpenAPI 3.x | ${result.summary.openapi3} |`,
    `| Swagger 2.x | ${result.summary.swagger2} |`,
    `| Parse Errors | ${result.summary.parseErrors} |`,
    `| **Total** | **${result.summary.total}** |`,
    '',
  ];

  if (result.specs.length === 0) {
    lines.push(
      '## No Specifications Found',
      '',
      'No OpenAPI or Swagger specifications were found in this directory.',
      ''
    );
  } else {
    lines.push('## Specifications Found', '');

    for (const spec of result.specs) {
      lines.push(`### ${spec.title || spec.filename}`, '');

      if (spec.error) {
        lines.push(`- **Path:** \`${spec.path}\``);
        lines.push(`- **Status:** Parse Error`);
        lines.push(`- **Error:** ${spec.error.message}`);
      } else {
        lines.push(`- **Path:** \`${spec.path}\``);
        lines.push(`- **Type:** ${spec.type}`);
        lines.push(`- **Version:** ${spec.version}`);
        if (spec.apiVersion)
          lines.push(`- **API Version:** ${spec.apiVersion}`);
        lines.push(`- **Paths:** ${spec.pathCount}`);
        lines.push(`- **Operations:** ${spec.operationCount}`);
        if (spec.servers?.length) {
          lines.push(`- **Servers:** ${spec.servers.join(', ')}`);
        }
        if (spec.tags?.length) {
          lines.push(`- **Tags:** ${spec.tags.join(', ')}`);
        }
        if (spec.isGenerated) {
          lines.push(
            `- **Generated:** Yes${
              spec.generatorComment ? ` (${spec.generatorComment})` : ''
            }`
          );
        }
        if (spec.description) {
          lines.push(
            `- **Description:** ${spec.description
              .split('\n')[0]
              .substring(0, 100)}...`
          );
        }
      }
      lines.push('');
    }
  }

  lines.push('## Next Steps', '');
  if (result.specs.length > 0) {
    const validSpecs = result.specs.filter((s) => !s.error);
    if (validSpecs.length > 0) {
      lines.push(
        `Run \`/api-review ${validSpecs[0].path}\` to analyze against AIP rules.`
      );
    }
  } else {
    lines.push('- Check if specs are in a different location');
    lines.push(
      '- Generate specs from code annotations if using a code-first approach'
    );
  }
  lines.push('');

  return lines.join('\n');
}

/**
 * Format output as JSON
 * @param {DiscoveryResult} result
 * @returns {string}
 */
function formatJSON(result) {
  return JSON.stringify(result, null, 2);
}

/**
 * Print help message
 */
function printHelp() {
  console.log(`
AIP OpenAPI Discovery
Find OpenAPI specifications in a codebase.

USAGE:
  aip-discover [directory] [options]

ARGUMENTS:
  [directory]         Directory to search (default: current directory)

OPTIONS:
  -h, --help            Show this help message
  -f, --format <fmt>    Output format: markdown (default), json
  -i, --ignore <glob>   Glob pattern to ignore (can be repeated)

DEFAULT IGNORES:
  **/node_modules/**, **/.git/**, **/dist/**, **/build/**,
  **/coverage/**, **/.next/**, **/.nuxt/**

EXAMPLES:
  # Discover in current directory
  aip-discover

  # Discover in specific path
  aip-discover ./api

  # JSON output
  aip-discover --format json

  # Ignore additional patterns
  aip-discover -i '**/vendor/**' -i '**/tmp/**'
`);
}

/**
 * Main CLI function
 * @param {string[]} args
 * @returns {Promise<number>}
 */
async function main(args) {
  const { values, positionals } = parseArgs({ ...argsConfig, args });

  // @ts-ignore
  if (values.help) {
    printHelp();
    return 0;
  }

  const searchPath = resolve(positionals[0] || '.');
  // @ts-ignore
  const format = /** @type {string} */ (values.format);
  // @ts-ignore
  const extraIgnores = /** @type {string[]} */ (values.ignore);
  const ignores = [...DEFAULT_IGNORES, ...extraIgnores];

  // Find spec files
  const files = await findSpecFiles(searchPath, ignores);

  // Analyze each spec
  /** @type {SpecInfo[]} */
  const specs = [];
  for (const file of files) {
    const info = await analyzeSpec(file, searchPath);
    specs.push(info);
  }

  // Build result
  /** @type {DiscoveryResult} */
  const result = {
    searchPath,
    discoveredAt: new Date().toISOString(),
    specs,
    summary: {
      total: specs.length,
      openapi3: specs.filter((s) => s.type.startsWith('openapi-3')).length,
      swagger2: specs.filter((s) => s.type === 'swagger-2.x').length,
      parseErrors: specs.filter((s) => s.error).length,
    },
  };

  // Output
  const output =
    format === 'json' ? formatJSON(result) : formatMarkdown(result);
  console.log(output);

  return 0;
}

// Export for testing
export {
  findSpecFiles,
  looksLikeSpec,
  detectGenerated,
  analyzeSpec,
  formatMarkdown,
  formatJSON,
  main,
  GLOB_PATTERNS,
  DEFAULT_IGNORES,
};

// Run CLI only when executed directly
const isMain = import.meta.url === `file://${process.argv[1]}`;
if (isMain) {
  const exitCode = await main(process.argv.slice(2));
  process.exit(exitCode);
}
