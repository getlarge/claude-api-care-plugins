diff --git a/node_modules/@platformatic/mcp/dist/auth/oauth-client.js b/node_modules/@platformatic/mcp/dist/auth/oauth-client.js
index 15dc96a..34f12f6 100644
--- a/node_modules/@platformatic/mcp/dist/auth/oauth-client.js
+++ b/node_modules/@platformatic/mcp/dist/auth/oauth-client.js
@@ -1,7 +1,54 @@
 import fp from 'fastify-plugin';
 import { createHash, randomBytes } from 'node:crypto';
 import { validateTokenResponse, validateIntrospectionResponse, validateClientRegistrationResponse } from "./oauth-schemas.js";
+
+// OIDC Discovery cache
+let discoveryCache = null;
+let discoveryCacheTime = 0;
+const DISCOVERY_CACHE_TTL = 5 * 60 * 1000; // 5 minutes
+
+async function discoverOIDCEndpoints(authorizationServer, logger) {
+    const now = Date.now();
+    if (discoveryCache && (now - discoveryCacheTime) < DISCOVERY_CACHE_TTL) {
+        return discoveryCache;
+    }
+
+    try {
+        const discoveryUrl = `${authorizationServer}/.well-known/openid-configuration`;
+        logger?.info({ discoveryUrl }, 'OAuth client: fetching OIDC discovery document');
+        const response = await fetch(discoveryUrl);
+        if (response.ok) {
+            const metadata = await response.json();
+            discoveryCache = {
+                authorizationEndpoint: metadata.authorization_endpoint,
+                tokenEndpoint: metadata.token_endpoint,
+                introspectionEndpoint: metadata.introspection_endpoint,
+                registrationEndpoint: metadata.registration_endpoint,
+            };
+            discoveryCacheTime = now;
+            logger?.info({ endpoints: discoveryCache }, 'OAuth client: OIDC endpoints discovered');
+            return discoveryCache;
+        }
+        logger?.warn({ status: response.status }, 'OAuth client: OIDC discovery failed, using defaults');
+    } catch (error) {
+        logger?.warn({ error: error.message }, 'OAuth client: OIDC discovery error, using defaults');
+    }
+
+    // Default endpoints (original behavior for backwards compatibility)
+    const defaults = {
+        authorizationEndpoint: `${authorizationServer}/oauth/authorize`,
+        tokenEndpoint: `${authorizationServer}/oauth/token`,
+        introspectionEndpoint: `${authorizationServer}/oauth/introspect`,
+        registrationEndpoint: `${authorizationServer}/oauth/register`,
+    };
+    discoveryCache = defaults;
+    discoveryCacheTime = now;
+    return defaults;
+}
+
 const oauthClientPlugin = async (fastify, opts) => {
+    // Discover OIDC endpoints on startup
+    const endpoints = await discoverOIDCEndpoints(opts.authorizationServer, fastify.log);
     // Our OAuth client implementation is completely independent and doesn't need @fastify/oauth2
     // @fastify/oauth2 can be optionally registered by users if they want the additional routes,
     // but our implementation provides all necessary OAuth client functionality
@@ -37,20 +84,20 @@ const oauthClientPlugin = async (fastify, opts) => {
             if (opts.resourceUri) {
                 params.set('resource', opts.resourceUri);
             }
-            const authorizationUrl = `${opts.authorizationServer}/oauth/authorize?${params.toString()}`;
+            const authorizationUrl = `${endpoints.authorizationEndpoint}?${params.toString()}`;
             return {
                 authorizationUrl,
                 state,
                 pkce
             };
         },
-        async exchangeCodeForToken(code, pkce, state, receivedState) {
+        async exchangeCodeForToken(code, pkce, state, receivedState, redirectUri) {
             // Validate state parameter to prevent CSRF
             if (state !== receivedState) {
                 throw new Error('Invalid state parameter - possible CSRF attack');
             }
             try {
-                const tokenResponse = await fetch(`${opts.authorizationServer}/oauth/token`, {
+                const tokenResponse = await fetch(endpoints.tokenEndpoint, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded',
@@ -61,7 +108,9 @@ const oauthClientPlugin = async (fastify, opts) => {
                         code,
                         client_id: opts.clientId || '',
                         code_verifier: pkce.codeVerifier,
-                        ...(opts.clientSecret && { client_secret: opts.clientSecret })
+                        ...(opts.clientSecret && { client_secret: opts.clientSecret }),
+                        // redirect_uri must match the one used in authorization request (required for OIDC)
+                        ...(redirectUri && { redirect_uri: redirectUri })
                     }).toString()
                 });
                 if (!tokenResponse.ok) {
@@ -84,7 +133,7 @@ const oauthClientPlugin = async (fastify, opts) => {
                 throw new Error('Refresh token is required');
             }
             try {
-                const tokenResponse = await fetch(`${opts.authorizationServer}/oauth/token`, {
+                const tokenResponse = await fetch(endpoints.tokenEndpoint, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded',
@@ -114,7 +163,7 @@ const oauthClientPlugin = async (fastify, opts) => {
         },
         async validateToken(accessToken) {
             try {
-                const introspectionResponse = await fetch(`${opts.authorizationServer}/oauth/introspect`, {
+                const introspectionResponse = await fetch(endpoints.introspectionEndpoint, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/x-www-form-urlencoded',
@@ -145,7 +194,7 @@ const oauthClientPlugin = async (fastify, opts) => {
                 throw new Error('Dynamic client registration not enabled');
             }
             try {
-                const registrationResponse = await fetch(`${opts.authorizationServer}/oauth/register`, {
+                const registrationResponse = await fetch(endpoints.registrationEndpoint, {
                     method: 'POST',
                     headers: {
                         'Content-Type': 'application/json',
diff --git a/node_modules/@platformatic/mcp/dist/auth/prehandler.js b/node_modules/@platformatic/mcp/dist/auth/prehandler.js
index afeb69a..1a70553 100644
--- a/node_modules/@platformatic/mcp/dist/auth/prehandler.js
+++ b/node_modules/@platformatic/mcp/dist/auth/prehandler.js
@@ -8,8 +8,14 @@ export function createAuthPreHandler(config, tokenValidator) {
         if (request.url.startsWith('/.well-known/') || request.url.startsWith('/mcp/.well-known')) {
             return;
         }
-        // Skip authorization for the start of the OAuth authorization flow.
-        if (request.url.startsWith('/oauth/authorize')) {
+        // Skip authorization for OAuth flow endpoints (authorize initiates, callback receives code)
+        if (request.url.startsWith('/oauth/authorize') || request.url.startsWith('/oauth/callback')) {
+            return;
+        }
+        // Skip authorization for custom excluded paths
+        if (config.excludedPaths?.some(path =>
+            typeof path === 'string' ? request.url.startsWith(path) : path.test(request.url)
+        )) {
             return;
         }
         // Extract Bearer token from Authorization header
diff --git a/node_modules/@platformatic/mcp/dist/decorators/meta.js b/node_modules/@platformatic/mcp/dist/decorators/meta.js
index bf8d066..edd4075 100644
--- a/node_modules/@platformatic/mcp/dist/decorators/meta.js
+++ b/node_modules/@platformatic/mcp/dist/decorators/meta.js
@@ -1,7 +1,7 @@
 import fp from 'fastify-plugin';
 import { schemaToArguments, validateToolSchema } from "../validation/index.js";
 const mcpDecoratorsPlugin = async (app, options) => {
-    const { tools, resources, prompts } = options;
+    const { tools, resources, prompts, resourceHandlers } = options;
     // Enhanced tool decorator with TypeBox schema support
     app.decorate('mcpAddTool', (definition, handler) => {
         const name = definition.name;
@@ -61,6 +61,13 @@ const mcpDecoratorsPlugin = async (app, options) => {
             handler
         });
     });
+    // Resource subscription handler setters
+    app.decorate('mcpSetResourcesSubscribeHandler', (handler) => {
+        resourceHandlers.subscribe = handler;
+    });
+    app.decorate('mcpSetResourcesUnsubscribeHandler', (handler) => {
+        resourceHandlers.unsubscribe = handler;
+    });
 };
 export default fp(mcpDecoratorsPlugin, {
     name: 'mcp-decorators'
diff --git a/node_modules/@platformatic/mcp/dist/handlers.js b/node_modules/@platformatic/mcp/dist/handlers.js
index 7d8b05e..9c91280 100644
--- a/node_modules/@platformatic/mcp/dist/handlers.js
+++ b/node_modules/@platformatic/mcp/dist/handlers.js
@@ -196,7 +196,17 @@ async function handleResourcesRead(request, sessionId, dependencies) {
     }
     const params = paramsValidation.data;
     const uri = params.uri;
-    const resource = resources.get(uri);
+    // Try exact match first
+    let resource = resources.get(uri);
+    // If not found and URI has query params, try base URI (for uriSchema pattern matching)
+    if (!resource && uri.includes('?')) {
+        const baseUri = uri.split('?')[0];
+        const baseResource = resources.get(baseUri);
+        // Only use base resource if it has uriSchema (expects query params)
+        if (baseResource?.definition?.uriSchema) {
+            resource = baseResource;
+        }
+    }
     if (!resource) {
         return createError(request.id, METHOD_NOT_FOUND, `Resource '${uri}' not found`);
     }
@@ -248,6 +258,46 @@ async function handleResourcesRead(request, sessionId, dependencies) {
         return createResponse(request.id, result);
     }
 }
+async function handleResourcesSubscribe(request, sessionId, dependencies) {
+    const { resourceHandlers } = dependencies;
+    // Use custom handler if set
+    if (resourceHandlers?.subscribe) {
+        try {
+            const result = await resourceHandlers.subscribe(request.params, {
+                sessionId,
+                request: dependencies.request,
+                reply: dependencies.reply,
+                authContext: dependencies.authContext
+            });
+            return createResponse(request.id, result);
+        }
+        catch (error) {
+            return createError(request.id, INTERNAL_ERROR, `Resource subscribe failed: ${error.message || error}`);
+        }
+    }
+    // No custom handler - return method not found
+    return createError(request.id, METHOD_NOT_FOUND, 'resources/subscribe handler not configured');
+}
+async function handleResourcesUnsubscribe(request, sessionId, dependencies) {
+    const { resourceHandlers } = dependencies;
+    // Use custom handler if set
+    if (resourceHandlers?.unsubscribe) {
+        try {
+            const result = await resourceHandlers.unsubscribe(request.params, {
+                sessionId,
+                request: dependencies.request,
+                reply: dependencies.reply,
+                authContext: dependencies.authContext
+            });
+            return createResponse(request.id, result);
+        }
+        catch (error) {
+            return createError(request.id, INTERNAL_ERROR, `Resource unsubscribe failed: ${error.message || error}`);
+        }
+    }
+    // No custom handler - return method not found
+    return createError(request.id, METHOD_NOT_FOUND, 'resources/unsubscribe handler not configured');
+}
 async function handlePromptsGet(request, sessionId, dependencies) {
     const { prompts } = dependencies;
     // Validate the request parameters structure
@@ -391,6 +441,10 @@ export async function handleRequest(request, sessionId, dependencies) {
                 return await handleToolsCall(request, sessionId, dependencies);
             case 'resources/read':
                 return await handleResourcesRead(request, sessionId, dependencies);
+            case 'resources/subscribe':
+                return await handleResourcesSubscribe(request, sessionId, dependencies);
+            case 'resources/unsubscribe':
+                return await handleResourcesUnsubscribe(request, sessionId, dependencies);
             case 'prompts/get':
                 return await handlePromptsGet(request, sessionId, dependencies);
             default:
diff --git a/node_modules/@platformatic/mcp/dist/index.js b/node_modules/@platformatic/mcp/dist/index.js
index 9991d82..6c4f810 100644
--- a/node_modules/@platformatic/mcp/dist/index.js
+++ b/node_modules/@platformatic/mcp/dist/index.js
@@ -26,6 +26,11 @@ const mcpPlugin = fp(async function (app, opts) {
     const tools = new Map();
     const resources = new Map();
     const prompts = new Map();
+    // Custom resource handlers for subscribe/unsubscribe
+    const resourceHandlers = {
+        subscribe: null,
+        unsubscribe: null
+    };
     // Initialize stores and brokers based on configuration
     let sessionStore;
     let messageBroker;
@@ -66,7 +71,8 @@ const mcpPlugin = fp(async function (app, opts) {
     app.register(metaDecorators, {
         tools,
         resources,
-        prompts
+        prompts,
+        resourceHandlers
     });
     app.register(pubsubDecorators, {
         enableSSE,
@@ -85,7 +91,8 @@ const mcpPlugin = fp(async function (app, opts) {
         prompts,
         sessionStore,
         messageBroker,
-        localStreams
+        localStreams,
+        resourceHandlers
     });
     // Add close hook to clean up Redis connections and authorization components
     app.addHook('onClose', async () => {
diff --git a/node_modules/@platformatic/mcp/dist/routes/auth-routes.js b/node_modules/@platformatic/mcp/dist/routes/auth-routes.js
index 7a13274..4fcdf7e 100644
--- a/node_modules/@platformatic/mcp/dist/routes/auth-routes.js
+++ b/node_modules/@platformatic/mcp/dist/routes/auth-routes.js
@@ -53,9 +53,13 @@ const authRoutesPlugin = async (fastify, opts) => {
         try {
             // eslint-disable-next-line camelcase
             const { resource, redirect_uri } = request.query;
+            // Build the callback URL for the OAuth flow
+            // Use request.host (includes port) instead of request.hostname (excludes port)
+            const callbackUrl = `${opts.resourceUri || `${request.protocol}://${request.host}`}/oauth/callback`;
             // Create authorization request with PKCE
             const authRequest = await fastify.oauthClient.createAuthorizationRequest({
-                ...(resource && { resource })
+                ...(resource && { resource }),
+                redirect_uri: callbackUrl
             });
             // Store session data in session store
             const sessionData = {
@@ -63,7 +67,9 @@ const authRoutesPlugin = async (fastify, opts) => {
                 pkce: authRequest.pkce,
                 resourceUri: resource,
                 // eslint-disable-next-line camelcase
-                originalUrl: redirect_uri
+                originalUrl: redirect_uri,
+                // Store the callback URL for token exchange (must match exactly)
+                callbackUrl
             };
             // Create session metadata with auth session data
             const sessionMetadata = {
@@ -128,8 +134,8 @@ const authRoutesPlugin = async (fastify, opts) => {
             const sessionData = sessionMetadata.authSession;
             // Clean up session data
             await sessionStore.delete(state);
-            // Exchange authorization code for tokens
-            const tokens = await fastify.oauthClient.exchangeCodeForToken(code, sessionData.pkce, sessionData.state, state);
+            // Exchange authorization code for tokens (include redirect_uri to match authorization request)
+            const tokens = await fastify.oauthClient.exchangeCodeForToken(code, sessionData.pkce, sessionData.state, state, sessionData.callbackUrl);
             // Return tokens to client or redirect with tokens
             if (sessionData.originalUrl) {
                 const redirectUrl = new URL(sessionData.originalUrl);
diff --git a/node_modules/@platformatic/mcp/dist/routes/mcp.js b/node_modules/@platformatic/mcp/dist/routes/mcp.js
index ec7073d..e51f70f 100644
--- a/node_modules/@platformatic/mcp/dist/routes/mcp.js
+++ b/node_modules/@platformatic/mcp/dist/routes/mcp.js
@@ -3,7 +3,7 @@ import fp from 'fastify-plugin';
 import { JSONRPC_VERSION, INTERNAL_ERROR } from "../schema.js";
 import { processMessage } from "../handlers.js";
 const mcpPubSubRoutesPlugin = async (app, options) => {
-    const { enableSSE, opts, capabilities, serverInfo, tools, resources, prompts, sessionStore, messageBroker, localStreams } = options;
+    const { enableSSE, opts, capabilities, serverInfo, tools, resources, prompts, sessionStore, messageBroker, localStreams, resourceHandlers } = options;
     async function createSSESession() {
         const sessionId = randomUUID();
         const session = {
@@ -157,7 +157,8 @@ const mcpPubSubRoutesPlugin = async (app, options) => {
                 prompts,
                 request,
                 reply,
-                authContext
+                authContext,
+                resourceHandlers
             });
             if (response) {
                 return response;
diff --git a/node_modules/@platformatic/mcp/dist/types/auth-types.d.ts b/node_modules/@platformatic/mcp/dist/types/auth-types.d.ts
index 28ca594..b108385 100644
--- a/node_modules/@platformatic/mcp/dist/types/auth-types.d.ts
+++ b/node_modules/@platformatic/mcp/dist/types/auth-types.d.ts
@@ -4,6 +4,8 @@ export type AuthorizationConfig = {
     enabled: true;
     authorizationServers: string[];
     resourceUri: string;
+    /** Paths to exclude from authorization (e.g., health checks). Supports string prefix or RegExp. */
+    excludedPaths?: (string | RegExp)[];
     tokenValidation: {
         introspectionEndpoint?: string;
         jwksUri?: string;
